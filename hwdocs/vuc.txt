This document describes vµc ISA as found on VP2 and VP3.

Address spaces:
    D[] - data memory address space (access via ld/st)
    E[] - io address space (access via iord/iowr)
    
Predicates:
    Most instructions can be conditionally executed depending on predicate state.

Invalid instructions: found no influence on machine state.
    
opcode format:
    0-7 select the instruction
    8-11 operand
    12-15 operand
    16-19 operand
    20-23
        predicated: predicate
        non-predicated: extra operand
    24-25 are extra 2 bits for immediates, or extra bit for selecting $i16-31 as opposed to $i0-15
    26 selects source operand 1: 0 is $rX, 1 is immediate
    27 selects source operand 2: 0 is $rX, 1 is immediate
    28 selects destination operand: 0 means $rX, 1 means $iX; 
    29: 0 for unpredicated insns, 1 for predicated insns
    
    --only vp2
    30-39: unknown purpose and are usually 0x3ff
    if all instructions have:
    0x000: all ok
    0x3fe: nothing runs
    0x3fd: nothing runs
    ...
    0x3f5: runs
    
    going up from 0x3f0, things stop running at 0x3f7

Opcodes:
Some opcodes repeat, some of those are "covered" by single variations. E.g. 0x8e can be sex or iowr, depending on source parameters. In the docs and envydis the variant used in the code is presented. It appears that the "override" opcode has 0x14000000 set, while base has one or more of those bts unset. XXX: check with "canonical" arithmetics at 0x6X.

"base" opcodes with mask 0x1f: 0x04, 0x05, 0x06, 0x0c, 0x0d, 0x0e
Other repeating "base" opodes: 0x21, 0x61

XXX: Find a io register responsible for overflow and carry
XXX: Find signedness of instructions
TODO: Find out exact immediate sizes in most instructions
NOTE: only 0x48-0x4a are confirmed to take predicates as arguments on NV96. Other "set"s were scanned but nothing found, even "orsetsg"s from nv96

Instructions:
Note: "a ^ b" signifies bitwise XOR, "a ** b" signifies "a to the power of b", "~a" signifies bitwise negation of a. ceil(), floor() and rand() are sign-aware, assume values to be of infinite precision. All signed values are noted when applicable/known.



* Flow:
	0x00: [bra TARGET]
          bra IMM?
        Branch to address.
        Delay: 1 instruction
    
	0x02: [call TARGET]
          call IMM?
        XXX: stack and calling convention
	0x03: [ret]
          ret
        TODO: delay (blob: 1)
        XXX: stack and calling convention
	0x43: [nop]
          nop
        Done!

* Predicate:
    0x28: [orsetsg DST SRC1 SRC2]
          orsetsg PRED REG GPREG
          orsetsg PRED REG IMM6
            DST := DST | (SRC1 > SRC2)
        Delay: immediate
    
    0x29: [orsetsl DST SRC1 SRC2]
          orsetsl PRED REG GPREG
          orsetsl PRED REG IMM6
            DST := DST | (SRC1 < SRC2)
        Delay: immediate
    
    0x2a: [orsetse DST SRC1 SRC2]
          orsetse PRED REG GPREG
          orsetse PRED REG IMM6
            DST := DST | (SRC1 == SRC2)
        Delay: immediate
    
    0xa8: [orsetsng DST SRC1 SRC2]
          orsetsng PRED REG GPREG
          orsetsng PRED REG IMM6
            signed SRC1, SRC2
            DST := DST | (SRC1 <= SRC2)
        Delay: immediate
    
    0xa9: [orsetsnl DST SRC1 SRC2]
          orsetsnl PRED REG GPREG
          orsetsnl PRED REG IMM6
            signed SRC1, SRC2
            DST := DST | (SRC1 >= SRC2)
        Delay: immediate
    
    0xaa: [orsetsne DST SRC1 SRC2]
          orsetsne PRED REG GPREG
          orsetsne PRED REG IMM6
            signed SRC1, SRC2
            DST := DST | (SRC1 != SRC2)
        Delay: immediate
            
    0x48: [setsg DST SRC1 SRC2]
          setsg PRED REG GPREG
          setsg PRED REG IMM6
            DST := SRC1 > SRC2
        Delay: immediate
        
    0x48: [setg DST SRC1 SRC2]
          setg PRED PRED PRED
            DST := SRC1 > SRC2
        Delay: immediate
    
    0x49: [setsl DST SRC1 SRC2]
          setsl PRED REG GPREG
          setsl PRED REG IMM6
            signed SRC1, SRC2
            DST := SRC1 < SRC2
        Delay: immediate
    
    0x49: [setle DST SRC1 SRC2]
          setle PRED PRED PRED
            DST := SRC1 <= SRC2
        Delay: immediate
    
    0x4a: [setse DST SRC1 SRC2]
          setse PRED REG GPREG
          setse PRED REG IMM6
            DST := SRC1 == SRC2
        Delay: immediate
    
    0x4a: [sete DST SRC1 SRC2]
          sete PRED PRED PRED
            DST := SRC1 == SRC2
        Delay: immediate
    
    0x4d: [orsetnand DST SRC1 SRC2]
          orsetnand PRED PRED PRED
            DST := DST | (~(SRC1 & SRC2))
        Delay: TODO
    
    0xc8: [setsle DST SRC1 SRC2]
          setsle PRED REG GPREG
          setsle PRED REG IMM6
            DST := SRC1 <= SRC2
        Delay: immediate
    
    0xc9: [setsge DST SRC1 SRC2]
          setsge PRED REG GPREG
          setsge PRED REG IMM6
            DST := SRC1 >= SRC2
        Delay: immediate
    
    0xca: [setsne DST SRC1 SRC2]
          setsne PRED REG GPREG
          setsne PRED REG IMM6
            DST := SRC1 != SRC2
        Delay: immediate
    
    0x40: [and DST SRC1 SRC2]
          and PRED PRED PRED
            DST := SRC1 & SRC2
        Delay: immediate
    
    0x41: [or DST SRC1 SRC2]
          or PRED PRED PRED
            DST := SRC1 | SRC2
        Delay: immediate
    
    0x42: [xor DST SRC1 SRC2]
          xor PRED PRED PRED
            DST := SRC1 ^ SRC2
        Delay: immediate
   
    0x44: [andn DST SRC1 SRC2]
          andn PRED PRED PRED
            DST := SRC1 & ~SRC2
        Delay: immediate
    
    0x45: [orn DST SRC1 SRC2]
          orn PRED PRED PRED
            DST := SRC1 | ~SRC2
        Delay: immediate
    
    0x46: [xorn DST SRC1 SRC2]
          xorn PRED PRED PRED
            DST := SRC1 == SRC2
            (DST := ~(SRC1 ^ SRC2)
        Delay: immediate
    
    0x32, 0x52: [btest DST SRC1 SRC2]
          btest PRED REG GPREG
          btest PRED REG IMM6
            DST := (SRC1 >> SRC2) & 1
        Only 2 forms.
        Delay: immediate

    0xd2: [btestn DST SRC1 SRC2]
          btestn PRED REG GPREG
          btestn PRED REG IMM6
            DST := ~((SRC1 >> SRC2) & 1)
        Delay: immediate
        
   
* Memory
    0x80: [st DST SRC]
		  st MEM[IMM10] GPREG
		  st MEM[GPREG] GPREG
		  st MEM[GPREG + IMM10] GPREG
		  st MEM[GPREG + GPREG] GPREG
		Predicated exceptions:
		  PRED st MEM[IMM6] GPREG
		  PRED st MEM[GPREG + IMM6] GPREG
        Store data into memory. If instruction is predicated, the immediate value will be shorter.
            DST := SRC
        Delay: immediate
    
    0x81: [ld DST SRC]
          ld GPREG MEM[IMM10]
          ld GPREG MEM[GPREG]
          ld GPREG MEM[GPREG + IMM10]
          ld GPREG MEM[GPREG + GPREG]
        Predicated exceptions:
          PRED ld GPREG MEM[IMM6]
          PRED ld GPREG MEM[GPREG + IMM6]
        Load data from memory MEM. If instruction is predicated, immediate is shorter.
            DST := SRC
        Delay: 2 * MOV. Value is being read immediately (or it seems so), delay applies to DST update.

* IO
    0x8f: [iord DST SRC]
          iord GPREG IO[IMM10]
          iord GPREG IO[GPREG]
          iord GPREG IO[GPREG + IMM10]
          iord GPREG IO[GPREG + GPREG]
        Predicated exceptions:
          PRED iord GPREG IO[IMM6]
          PRED iord GPREG IO[GPREG + IMM6]
        Read data from IO address space - a copy of [ld] instruction. If predicated, immediate is shorter.
        XXX: verify predicated forms
            DST := SRC
        Delay: 2 * MOV. Value is being read immediately (or it seems so), delay applies to DST update.
    
    0x8e: [iowr DST SRC]
          iowr IO[IMM10] GPREG
          iowr IO[GPREG] GPREG
          iowr IO[GPREG + IMM10] GPREG
        Predicated exceptions:
          PRED iowr IO[IMM6] GPREG
          PRED iowr IO[GPREG + IMM6] GPREG
        Write data into IO address space. If instruction is predicated, the immediate value will be shorter.
        XXX: verify all forms
            DST := SRC
        Delay: immediate
        
* Arithmetic
    0x61: [mov DST SRC]
          mov REG GPREG
          mov GPREG IMM14
          mov IOREG IMM12
        Sets DST to value of SRC.
        "Base" opcode - actually 0x01.
            DST := SRC
        Delay: immediate
        
    0x60: [slct DST SRC1 SRC2 SRC3]
          slct REG PRED GPREG
          slct REG PRED IMM6?
            if SRC1
                DST := SRC2
            else
                DST := SRC3
            endif
        TODO: There exists a predicated version with bit 29 set, predicate in 20:24, DST := SRC3.
        "Base" opcode - actually 0x00.
        Delay: immediate

	0x64: [add DST SRC1 SRC2]
		  add REG REG GPREG
		  add REG REG IMM6
		Assigns DST the value of SRC1 + SRC2
			DST := SRC1 + SRC2
		XXX: Flags?
		"Base" opcode - actually 0x04.
		Delay: immediate
    
    0x65: [sub DST SRC1 SRC2]
          sub REG GPREG GPREG
          sub GPREG REG GPREG
          sub REG GPREG IMM6
          sub GPREG REG IMM6
            DST := SRC1 - SRC2
        XXX: Flags?
        "Base" opcode - actually 0x65.
        Delay: immediate
        
    0x66: [subr DST SRC1 SRC2]
          subr REG REG GPREG
          subr REG REG IMM6
            DST := SRC2 - SRC1
        XXX: Flags?
        "Base" opcode - actually 0x66.
        Only present on VP2
        Delay: immediate
        0x67: [clear DST]
          clear REG
            DST := 0
        "Base opcode - actually 0x07.
        Delay: immediate
        
    0x6c: [minsz DST SRC1 SRC2]
          minsz REG GPREG
          minsz REG IMM6?
        Signed minimum with a quirk.
        Arithmetic, 0x1f mask
            signed SRC1, SRC2
            if SRC1 > SRC2
                DST := SRC2
            else
                DST := max(SRC1, 0)
            endif
        "Base" opcode - actually 0x0c.
        Delay: immediate
    
    0x6d: [clampsex DST SRC1 SRC2]
          clampsex REG GPREG
          clampsex REG IMM6?
        Clamp SRC1 to -2**SRC2..2**SRC2-1. If SRC1 is not in the interval, DST becomes the closer interval boundary. Otherwise DST becomes SRC1.
            signed SRC1
            if SRC1 < 0
                DST := (-(2 ** SRC2)) | SRC1
            else
                DST := ((2 ** SRC1) - 1) & SRC1
            end
        "Base" opcode - actually 0x0d.
        Delay: immediate
    
    0x0e, 0x4e, 0x6e: [sex DST SRC1 SRC2]
          sex REG REG GPREG
          sex REG REG IMM6?
        Sign extend all bits from SRC2 and higher (truncate SRC1 to SRC2 bits, then cast it back with sign to 16 bits).
            if SRC1 & (2 ** SRC2)
                DST := (-(2 ** SRC2)) | SRC1
            else
                DST := ((2 ** SRC1) - 1) & SRC1
            end
        "Base" opcode - actually 0x0e.
        0x0e is used with 0x00a00000 set
        Delay: immediate
    
    0x6f: [div2s DST SRC]
          div2s REG REG
        Signed division by 2, round to 0
            signed SRC
            if SRC < 0
                DST := ceil(SRC / 2)
            else
                DST := floor(SRC / 2)
            endif
        Not present on vp2?
    
    0x66: [avgs DST SRC1 SRC2]
          avgs REG REG GPREG
          avgs REG REG IMM?
        Signed average
            signed SRC1, SRC2
            DST := ceil((SRC1 + SRC2) / 2)
        Present on vp3
        Not present on vp2?
        Delay: immediate
    
    0x67: [avgu DST SRC1 SRC2]
          avgu REG REG GPREG
          avgu REG REG IMM?
        Unsigned average
            DST := ceil((SRC1 + SRC2) / 2)
        Present on vp3
        Not present on vp2?
        Delay: immediate
    
    0xa0: [mul SRC1 SRC2]
          absmul GPREG GPREG
            if SRC2 >= 2 ** 10
                $arthi:$artlo := 0
            else
                $arthi:$artlo := SRC1 * SRC2
            endif
        Unsigned multiplication. SRC2 is 10 bit unsigned.
        "Override" opcode.
    
    0xa1: [muls SRC1 SRC2]
          muls GPREG GPREG
            signed SRC1, SRC2
            if SRC2 >= 2 ** 10 or SRC2 < -(2 ** 10)
                $arthi:$artlo := 0
            else
                $arthi:$artlo := SRC1 * sex(SRC2, 10)
            endif
        Signed multiplication. SRC2 is 10 bit signed.
        "Override" opcode.
        Delay: ???
    
    0xa2: [shift SRC]
          shift GPREG
          shift IMM4
            if SRC >= 2 ** 10
                SHIFT := 1
            else
                SHIFT := SRC + 1
            endif
            $arthi:artlo := $arthi:$artlo >> SHIFT
        Shift. XXX: verify what happens if SRC exceeds limit, check signedness.
        Delay: ???
    
    0x7d: [min DST SRC1 SRC2]
          min REG REG GPREG
          min REG REG IMM?
        Minimum.
        XXX: signed?
            DST := min(SRC1, SRC2)
        Present on vp3
        Not present on vp2?
        Delay: immediate
    
    0x7e: [max DST SRC1 SRC2]
          max REG REG GPREG
          max REG REG IMM?
        Maximum.
        XXX: signed?
            DST := max(SRC1, SRC2)
        Present on vp3
        Not present on vp2?
        Delay: immediate
    
    0x70: [bset DST SRC1 SRC2]
          bset REG REG GPREG
          bset REG REG IMM4
        Set bit SRC2 in SRC1.
            DST := SRC1 | (1 << SRC1)
        Delay: immediate
    
    0x71: [bclr DST SRC1 SRC2]
          bclr REG REG GPREG
          blcr REG REG IMM4
        Clear bit.
            DST := SRC1 & ~(1 << SRC1)
        Delay: immediate
    
    0x74: [rot8 DST SRC]
          rot8 REG REG
        Swap bytes.
            DST := ((SRC & 0xff) << 16) | (SRC >> 16)
        Delay: immediate
    
	0x75: [shl DST SRC1 SRC2]
		  shl REG REG GPREG
		  shl REG REG IMM4
		Assigns DST value of SRC1 shifted left by SRC2 bits.
			DST := SRC1 << SRC2
		Delay: immediate
		
	0x76: [shr DST SRC1 SRC2]
          shr REG REG GPREG
          shr REG REG IMM4
        Assigns DST value of SRC1 shifted right by SRC2 bits.
            DST := SRC1 >> SRC2
        Delay: immediate
    
    0x77: [sar DST SRC1 SRC2]
          sar REG REG GPREG
          sar REG REG IMM4
        Assigns DST value of SRC1 shifted right by SRC2 bits, preserving the sign bit.
            if SRC1 < 0
                DST := (0xffff0000 | SRC1) >> SRC2
            else
                DST := SRC1 >> SRC2
            endif
        Delay: immediate
    
    0x78: [and DST SRC1 SRC2]
          and REG REG GPREG
          and REG REG IMM6?
            DST := SRC1 & SRC2
        Delay: immediate
	
	0x79: [or DST SRC1 SRC2]
          or REG REG GPREG
          or REG REG IMM6?
            DST := SRC1 | SRC2
        Delay: immediate
	
	0x7a: [xor DST SRC1 SRC2]
          xor REG REG GPREG
          xor REG REG IMM6?
            DST := SRC1 ^ SRC2
        Delay: immediate
    
    0x7b: [not DST SRC]
          not REG REG
            DST := ~SRC
        Delay: immediate
	
	0x7d: [min DST SRC1 SRC2]
          min REG REG GPREG
          min REG REG IMM6?
            DST := min(SRC1, SRC2)
        Delay: immediate
	
	0x58: [andsnz PRED DST SRC1 SRC2]
		  andsnz PRED REG REG GPREG
		  andsnz PRED REG REG IMM6?
		Assigns DST value of bitwise AND of SRC1 and SRC2, sets PRED if DST != 0.
			DST := SRC1 & SRC2
			PRED := DST != 0
		Delay: immediate
    
    0x59: [orsnz PRED DST SRC1 SRC2]
          orsz PRED REG REG GPREG
          orsz PRED REG REG IMM6?
        Assigns DST value of bitwise OR of SRC1 and SRC2, sets PRED if DST != 0.
            DST := SRC1 & SRC2
            PRED := DST != 0
        Delay: immediate
    
    0xd8: [andsz PRED DST SRC1 SRC2]
          andsz PRED REG REG GPREG
          andsz PRED REG REG IMM6?
        Assigns DST value of bitwise AND of SRC1 and SRC2, sets PRED if DST == 0.
            DST := SRC1 & SRC2
            PRED := DST == 0
        Delay: immediate
    
    0xd9: [orsz PRED DST SRC1 SRC2]
          orsz PRED REG REG GPREG
          orsz PRED REG REG IMM6?
        Assigns DST value of bitwise OR of SRC1 and SRC2, sets PRED if DST == 0.
            DST := SRC1 & SRC2
            PRED := DST == 0
        Delay: immediate
    
* Unknown
    0x04: I/O?
        Version 0x34f00004 stops execution. I/O wait? Reads from $sr6 afterwards, always preceded by 0x20 slct $sr->$sr
    
    0x08, 0x09, 0x0a, 0x0b: Arithmetic? Looks like _or_sets block (not on vp2)
    
    0x5c: Arithmetic.
        Sets PRED if SRC & f == a?
        Performs normal 0x7c in addition.
        Delay: immediate
    
    0x83: I/O? Memory load type
        Memory space unknown, labeled F.
        Composed of 8-byte structures.
        XXX: address space size
        Delay: 2 * MOV
    
    0x89: I/O? Memory load type
        Memory space unknown, labeled G.
        Composed of 8-byte structures.
        XXX: address space size
        Delay: 2 * MOV
    
    0x84: I/O? ?DST SRC1
		  unk84 ?IOREG GPREG[12:16]
		  [8:12]: (0, 2, 3, 4, 5)
		  [16:20]: all
          [20:24]: (0, 1, 2)
          [25]: 1, 0 # extra 1
          [26:]: const
		  some sort of memory write?
		  
		if 28:32 < 0xc then disable 
        

    0x8d: I/O? Memory load type.
        Always yields 2. Predicates can be applied. Only used in h264, only in the form of 0x1c05008d.
        Blob ORs it with [$sr28|$sr29] ored with [0x8|0x4], then writes to E[2].
        Delay: 2 * MOV
    
    0x7c: DST SRC1 SRC2
          unk7c GPREG? GPREG? IMM?
          DST: 16:20
          SRC1: ?
          SRC2: ?
            if src2 == 3: dst := MOONPHASE(0x1f | 0)
            if src2 == 7: dst := MOONPHASE(0x1f | 0)
            if src2 == 8: dst := 4
            if src2 == 9: dst := 0 + (src1 % 4) * 4
            if src2 == 0xa: dst := 100 + src1 % 4
            else: dst:= 0
        delay: immediate
        
    0x05: I/O?
        Usage: alternated with $sr6 writes.
    0x24: I/O
        no params (?)
        First run: change $sr16-$sr21, $sr24 and $sr27-$sr31.
        Consecutive runs: change $sr16-$sr24 and $sr27-$sr31 ($sr22, $sr23 == 1).
        "Override" opcode.
        XXX: delay (blob: 5)
        
    0xa4, 0xa8, 0xac: Only after multiplication. 2, 2 or 1, plenty delay (blob).
    
registers:
- 16-bit:
    $r0 - hardwired 0
    $r1-$r15 - general purpose
- 1-bit predicate:
    $p0 - general purpose
    $p1 - ~$p0 (envydis: $np0)
    $p2-$p14 - general purpose
    $p15 - hardwired to 1.
- 64 × 16-bit special registers
    $sr8 ($pc): PC
    $sr12 ($arthi): Arithmetic result high word register
    $sr13 ($artlo): Arithmetic result low word register
    $sr14 ($pred): predicate bitfield ($p0 == $pred[0])
    $sr15 ($cnt): cycle counter (?: check nops, effect of delays)
    
    Unknown:
    $sr0: controls $sr48-$sr58 (bits 0-6 when set separately)
    $sr1: similar to $sr0 (bits 0-4, probably more)
    $sr2: bits 0-3 affect registers $sr16-$sr24
    $sr3: bits 0-4 affect $sr32-$sr42
    $sr6: writing 0x8000 alternates values between 0x8103 and 0
    $sr9: values 0, 1, 3, may be related to upload/execution order
    $sr10: usually 0, but may be different (negative) after reupload
    $sr16: modifies $sr17-$sr24, $sr27-$sr31
    $sr17-$sr24: modified by $sr16
    $sr22-$sr24: related to orsetreg's unknown bits, regardless of result
    $sr27-$sr31: modified by $sr16
    $sr32-$sr42: affected by $sr3
    $sr48-$sr58: affected by writing $sr0 and $sr1
    
    
    $sr4, $sr9, $sr12-$sr15, $sr27: nonzero
    No change on write:
    $sr4, $sr8-$sr10, $sr12-$sr15, $sr32+
    No side effects on read/write:
    $sr5, $sr28, $sr31 over all bits
    