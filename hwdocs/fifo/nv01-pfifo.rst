.. _nv01-pfifo:

======================
NV01:NV04 PFIFO engine
======================

.. contents::

.. note::

    This file deals only with NV01:NV04 PFIFO. For other GPUs, read:

    * NV04:NV50 - :ref:`NV04:NV50 PFIFO<nv04-pfifo>`
    * NV50:NVC0 - :ref:`NV50:NVC0 PFIFO<nv50-pfifo>`
    * NVC0+ - :ref:`NVC0+ PFIFO<nvc0-pfifo>`

Introduction
============

PFIFO is the functional unit in charge of collecting engine commands from user
applications and delivering them to PGRAPH. See fifo/intro.txt for an overview
of its construction.

PFIFO is controlled by PMC.ENABLE bit 8 and is connected to PMC interrupt 8.
Setting PMC.ENABLE bit 8 to 0 forces the following registers to 0 [but doesn't
otherwise affect PFIFO]:

- WAIT_RETRY
- INTR_EN
- RAMHT [on NV03 only]
- RAMFC [on NV03 only] - forced to 0x1c00 instead
- RAMRO [on NV03 only] - forced to 0x1e00 instead
- CACHES
- CACHE*.PUSH_ACCESS
- CACHE*.PULL_CTRL bit 0
- CACHE1.DMA_CTRL
- CACHE1.PULL_STATE [on NV03 only]


The MMIO registers
==================

=============== ===================== ============
Address         Name                  Description
=============== ===================== ============
002040          WAIT_RETRY            ??? [XXX]
002080          CACHE_ERROR           puller error status
002100          INTR                  interrupt status / acknowledge
002140          INTR_EN               interrupt enable
002200          CONFIG                pusher configuration
002210 [3]_     RAMHT                 RAMHT pointer and configuration
002214 [3]_     RAMFC                 RAMFC pointer
002218 [3]_     RAMRO                 RAMRO pointer and configuration
002400          RUNOUT_STATUS         RAMRO status
002410          RUNOUT_PUT            RAMRO write pointer
002420          RUNOUT_GET            RAMRO read pointer
002500          CACHES_REASSIGN       CACHE channel switch control
002800          DEVICE                PGRAPH engine status ?
003000          CACHE0.PUSH_ACCESS    CACHE0 pusher enable
003010 [1]_     CACHE0.CHID           CACHE0 channel ID
003020 [1]_     CACHE0.STATUS         CACHE0 status
003030 [1]_     CACHE0.PUT            CACHE0 pusher write pointer
003004 [3]_     CACHE0.CHID           CACHE0 channel ID
003010 [3]_     CACHE0.PUT            CACHE0 pusher write pointer
003014 [3]_     CACHE0.STATUS         CACHE0 status
003040          CACHE0.PULL_CTRL      CACHE0 puller control
003050 [1]_     CACHE0.PULL_STATE     CACHE0 puller state
003070          CACHE0.GET            CACHE0 puller read pointer
003080          CACHE0.CTX            CACHE0 puller context
003100          CACHE0.ADDR           CACHE0 entry - address
003104          CACHE0.DATA           CACHE0 entry - data
003200          CACHE1.PUSH_ACCESS    CACHE1 pusher enable
003210 [1]_     CACHE1.CHID           CACHE1 channel ID
003220 [1]_     CACHE1.STATUS         CACHE1 status
003230 [1]_     CACHE1.PUT            CACHE1 pusher write pointer
003204 [3]_     CACHE1.CHID           CACHE1 channel ID
003210 [3]_     CACHE1.PUT            CACHE1 pusher write pointer
003214 [3]_     CACHE1.STATUS         CACHE1 status
003218 [3]_     CACHE1.DMA_STATE      CACHE1 DMA pusher state
003220 [3]_     CACHE1.DMA_CTRL       CACHE1 DMA pusher control and status
003224 [3]_     CACHE1.DMA_COUNT      CACHE1 DMA pusher data buffer counter
003228 [3]_     CACHE1.DMA_GET        CACHE1 DMA pusher data buffer pointer
00322c [3]_     CACHE1.DMA_TARGET     CACHE1 DMA pusher data buffer target
003230 [3]_     CACHE1.DMA_TLB_TAG    CACHE1 DMA pusher data buffer TLB tag
003234 [3]_     CACHE1.DMA_TLB_PTE    CACHE1 DMA pusher data buffer TLB entry
003238 [3]_     CACHE1.DMA_PT_INST    CACHE1 DMA pusher data buffer page table address
003240          CACHE1.PULL_CTRL      CACHE1 puller control
003250          CACHE1.PULL_STATE     CACHE1 puller state
003270          CACHE1.GET            CACHE1 puller read pointer
003280+i*16     CACHE1.CTX[8]         CACHE1 puller context
003300+i*8 [2]_ CACHE1.ADDR[32]       CACHE1 entries - address
003304+i*8 [2]_ CACHE1.DATA[32]       CACHE1 entries - data
003400+i*8 [4]_ CACHE1.ADDR[64]       CACHE1 entries - address
003404+i*8 [4]_ CACHE1.DATA[64]       CACHE1 entries - data
=============== ===================== ============


.. [0] available on NV01, NV03 and NV03T cards
.. [1] available on NV01 only
.. [2] available on NV01 and NV03, but not NV03T
.. [3] available on NV03 and NV03T, but not NV01
.. [4] available on NV03T only

.. _nv01-pfifo-intr:

Interrupt reporting
===================

The following registers deal with reporting PFIFO interrupts:

MMIO 0x002100: INTR
  Status of interrupts generated by PFIFO. On read, returns 1 for bits
  corresponding to pending interrupts. On write, if 1 is written to a bit,
  its interrupt gets cleared, if 0 is written nothing happens.
MMIO 0x002140: INTR_EN
  Interrupt enable bitmask. Set to enable, clear to disable. Interrupts that
  are masked will still show up in INTR when they're triggered, but won't
  cause the PFIFO interrupt line to go active.
The bitfields common to these registers are:
  === =============== ===========
  Bit Name            Description
  === =============== ===========
  0   PULLER_ERROR    puller had a problem while processing a command
  4   RUNOUT          pusher rejected a PIO FIFO access and wrote an entry to RAMRO
  8   RUNOUT_OVERFLOW like above, but RAMRO was full and the entry was discarded
  12  DMA_PUSHER      the DMA pusher read a malformed command stream [NV03+]
  16  DMA_PTE         the DMA pusher got a page fault when reading the command stream [NV03+]
  === =============== ===========

.. todo:: CACHE_ERROR reg

The memory structures
=====================

The NV01/NV03 PFIFO uses three memory structures that reside in RAMIN:

- RAMHT, the puller hash table - can be 0x1000, 0x2000, 0x4000, or 0x8000
  bytes long, depending on configuration
- RAMFC, the puller context save area - 0x20 bytes per channel, on NV01
  it's always half the size of RAMHT, thus using 0x1000-byte RAMHT makes
  half the channels useless, and using >0x2000-byte RAMHT wastes RAMIN
  space. On NV03, it's always 0x1000 bytes [128 channels] long.
- RAMRO, the pusher runout area - made of 8-byte entries, always half
  the size of RAMHT on NV01, either 0x200 or 0x2000 bytes long on NV03.

In addition to these, NV03 also uses the page table part of standard DMA
object structure to access the DMA command buffer.

On NV01, these three structures reside at fixed addresses in RAMIN, selected
based on the PRAM size configuration [see :ref:`NV01 RAMIN configuration <nv01-pram-mmio-config>`]. There are
special MMIO areas provided for easy access to them. On NV03, the structures
can be located anywhere in the first 64kB of RAMIN, settable via the
configuration registers:

MMIO 0x002210: RAMHT [NV03-]
  bits 12-15 bits 12-15 of RAMHT start address inside RAMIN

  bits 16-17 RAMHT size
    = ========
    0 0x1000 bytes
    1 0x2000 bytes
    2 0x4000 bytes
    3 0x8000 bytes
    = ========

  The RAMHT address always has to be 0x1000-byte aligned.

MMIO 0x002214: RAMFC [NV03-]
  bits 9-15: bits 9-15 of RAMFC start address inside RAMIN

  The RAMFC address always has to be 0x200-byte aligned.

MMIO 0x002218: RAMRO [NV03-]
  bits 9-15: bits 9-15 of RAMRO start address inside RAMIN

  bit 16: RAMRO size
    = =========
    0 0x200 bytes [64 entries]
    1 0x2000 bytes [1024 entries]
    = =========

  The RAMRO address always has to be 0x200-byte aligned.

The cache
=========

The cache is a "waiting area" for the commands submitted through PFIFO. There
are two caches: the 32-entry [NV01, NV03] or 64-entry [NV03T] CACHE1, which is
used for normal submission and the 1-entry CACHE0, available for manually
injecting PGRAPH commands as part of software method execution, if needed.

A single cache entry holds one command and consists of:

- 3-bit subchannel id
- 11-bit method
- 32-bit data

The channel id is not stored in the cache entries - it's stored in a pusher
register instead. This means that all commands in the cache have to belong
to the same channel - pusher will refuse attempts to submit commands on
a channel different from its current channel if it's unable to switch to
it [ie. there's something in the cache already or channel switching is
manually disabled].

The CACHE1 entries are indexed in Gray code instead of normal binary code.

.. todo::

.. todo:: CACHE access regs

.. todo:: GET/PUT regs

.. todo:: status regs


The pusher
==========

.. todo:: write me


FIFO submission area
--------------------

.. todo:: write me


RAMRO
-----

.. todo:: write me


DMA submission
--------------

.. todo:: write me


The puller
==========

.. todo:: write me


RAMFC
=====

.. todo:: write me


RAMHT
=====

.. todo:: write me
